<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <title>Lab_2_Sobolev_</title>
        <style type="text/css">
            body { margin: 1; }
            canvas { width: 30%; height: 30% }
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script>
            // Соболев А. Ю. М8О-307Б
            // Вариант №17: 4-гранная прямая правильная усеченная пирамида
            var container;
            var camera, scene, renderer;
            var pyramid;

            var targetRotationX = 0.5;
            var targetRotationOnMouseDownX = 0;

            var targetRotationY = 0.2;
            var targetRotationOnMouseDownY = 0;

            var mouseX = 0;
            var mouseXOnMouseDown = 0;

            var mouseY = 0;
            var mouseYOnMouseDown = 0;

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;

            var slowingFactor = 0.2;

            init();
            animate();

            function init() {
                container = document.createElement( 'div' );
                document.body.appendChild( container );

                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xffffff );

                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.y = 150;
                camera.position.z = 500;
                scene.add( camera );

                pyramid = new THREE.Mesh( new THREE.CylinderGeometry( 30, 60, 100, 4, 4 ), new THREE.MeshNormalMaterial() );
                pyramid.position.y = 150;
                pyramid.overdraw = true;
                scene.add( pyramid );

                renderer = new THREE.WebGLRenderer({ alpha: true });
                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'wheel', onDocumentMouseWheel, false );
            }

            function onDocumentMouseDown( event ) {
                event.preventDefault();

                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );
                document.addEventListener( 'mouseout', onDocumentMouseOut, false );

                mouseXOnMouseDown = event.clientX - windowHalfX;
                targetRotationOnMouseDownX = targetRotationX;

                mouseYOnMouseDown = event.clientY - windowHalfY;
                targetRotationOnMouseDownY = targetRotationY;
            }

            function onDocumentMouseMove( event ) {
                mouseX = event.clientX - windowHalfX;
                targetRotationX = ( mouseX - mouseXOnMouseDown ) * 0.00025;
                mouseY = event.clientY - windowHalfY;
                targetRotationY = ( mouseY - mouseYOnMouseDown ) * 0.00025;
            }

            function onDocumentMouseUp( event ) {
                document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
                document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
                document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
            }

            function onDocumentMouseOut( event ) {
                document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
                document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
                document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
            }

            function onDocumentMouseWheel( event ) {
                var factor = 15;
                var mX = (event.clientX / window.innerWidth) * 2 - 1;
                var mY = -(event.clientY / window.innerHeight) * 2 + 1;
                var vector = new THREE.Vector3(mX, mY, 0.1);

                vector.unproject(camera);
                vector.sub(camera.position);
                if (event.deltaY < 0) {
                    camera.position.addVectors(camera.position, vector.setLength(factor));
                } else {
                    camera.position.subVectors(camera.position, vector.setLength(factor));
                }
            }

            function animate() {
                requestAnimationFrame( animate );

                rotateAroundWorldAxis(pyramid, new THREE.Vector3(0, 1, 0), targetRotationX);
                rotateAroundWorldAxis(pyramid, new THREE.Vector3(1, 0, 0), targetRotationY);
                
                targetRotationY = targetRotationY * (1 - slowingFactor);
                targetRotationX = targetRotationX * (1 - slowingFactor);
                renderer.render( scene, camera );
            }

            function rotateAroundWorldAxis( object, axis, radians ) {
                var rotationMatrix = new THREE.Matrix4();

                rotationMatrix.makeRotationAxis( axis.normalize(), radians );
                rotationMatrix.multiply( object.matrix );

                object.matrix = rotationMatrix;
                object.rotation.setFromRotationMatrix( object.matrix );
            }
        </script>
    </body>
</html>